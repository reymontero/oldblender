/**
 * $Id:$
 * ***** BEGIN GPL/BL DUAL LICENSE BLOCK *****
 *
 * The contents of this file may be used under the terms of either the GNU
 * General Public License Version 2 or later (the "GPL", see
 * http://www.gnu.org/licenses/gpl.html ), or the Blender License 1.0 or
 * later (the "BL", see http://www.blender.org/BL/ ) which has to be
 * bought from the Blender Foundation to become active, in which case the
 * above mentioned GPL option does not apply.
 *
 * The Original Code is Copyright (C) 2002 by NaN Holding BV.
 * All rights reserved.
 *
 * The Original Code is: all of this file.
 *
 * Contributor(s): none yet.
 *
 * ***** END GPL/BL DUAL LICENSE BLOCK *****
 */

#include "imbuf.h"

#include "convert_arrays.h"

#define OBJECTBLOK "hamx"

uchar hamx_array_char[] = {
	0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF,
	0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0xFF,0xFF,
	0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF,
	0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF, 0x00,0xFF,0x00,0xFF,
	0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00,
	0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00, 0x00,0xFF,0xFF,0x00,
	
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	
	0x00,0x00,0x00,0x00, 0x00,0x10,0x00,0x00, 0x00,0x20,0x00,0x00, 0x00,0x30,0x00,0x00, 0x00,0x40,0x00,0x00, 0x00,0x50,0x00,0x00, 0x00,0x60,0x00,0x00, 0x00,0x70,0x00,0x00,
	0x00,0x80,0x00,0x00, 0x00,0x90,0x00,0x00, 0x00,0xA0,0x00,0x00, 0x00,0xB0,0x00,0x00, 0x00,0xC0,0x00,0x00, 0x00,0xD0,0x00,0x00, 0x00,0xE0,0x00,0x00, 0x00,0xF0,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x10,0x00, 0x00,0x00,0x20,0x00, 0x00,0x00,0x30,0x00, 0x00,0x00,0x40,0x00, 0x00,0x00,0x50,0x00, 0x00,0x00,0x60,0x00, 0x00,0x00,0x70,0x00,
	0x00,0x00,0x80,0x00, 0x00,0x00,0x90,0x00, 0x00,0x00,0xA0,0x00, 0x00,0x00,0xB0,0x00, 0x00,0x00,0xC0,0x00, 0x00,0x00,0xD0,0x00, 0x00,0x00,0xE0,0x00, 0x00,0x00,0xF0,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x10, 0x00,0x00,0x00,0x20, 0x00,0x00,0x00,0x30, 0x00,0x00,0x00,0x40, 0x00,0x00,0x00,0x50, 0x00,0x00,0x00,0x60, 0x00,0x00,0x00,0x70,
	0x00,0x00,0x00,0x80, 0x00,0x00,0x00,0x90, 0x00,0x00,0x00,0xA0, 0x00,0x00,0x00,0xB0, 0x00,0x00,0x00,0xC0, 0x00,0x00,0x00,0xD0, 0x00,0x00,0x00,0xE0, 0x00,0x00,0x00,0xF0,
	
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x30, 0x00,0x00,0x00,0x60, 0x00,0x00,0x00,0x90, 0x00,0x00,0x00,0xC0, 0x00,0x00,0x00,0xF0,
	0x00,0x00,0x20,0x00, 0x00,0x00,0x20,0x30, 0x00,0x00,0x20,0x60, 0x00,0x00,0x20,0x90, 0x00,0x00,0x20,0xC0, 0x00,0x00,0x20,0xF0,
	0x00,0x00,0x40,0x00, 0x00,0x00,0x40,0x30, 0x00,0x00,0x40,0x60, 0x00,0x00,0x40,0x90, 0x00,0x00,0x40,0xC0, 0x00,0x00,0x40,0xF0,
	0x00,0x00,0x60,0x00, 0x00,0x00,0x60,0x30, 0x00,0x00,0x60,0x60, 0x00,0x00,0x60,0x90, 0x00,0x00,0x60,0xC0, 0x00,0x00,0x60,0xF0,
	0x00,0x00,0x90,0x00, 0x00,0x00,0x90,0x30, 0x00,0x00,0x90,0x60, 0x00,0x00,0x90,0x90, 0x00,0x00,0x90,0xC0, 0x00,0x00,0x90,0xF0,
	0x00,0x00,0xB0,0x00, 0x00,0x00,0xB0,0x30, 0x00,0x00,0xB0,0x60, 0x00,0x00,0xB0,0x90, 0x00,0x00,0xB0,0xC0, 0x00,0x00,0xB0,0xF0,
	0x00,0x00,0xD0,0x00, 0x00,0x00,0xD0,0x30, 0x00,0x00,0xD0,0x60, 0x00,0x00,0xD0,0x90, 0x00,0x00,0xD0,0xC0, 0x00,0x00,0xD0,0xF0,
	0x00,0x00,0xF0,0x00, 0x00,0x00,0xF0,0x30, 0x00,0x00,0xF0,0x60, 0x00,0x00,0xF0,0x90, 0x00,0x00,0xF0,0xC0, 0x00,0x00,0xF0,0xF0,
	0x00,0x50,0x00,0x00, 0x00,0x50,0x00,0x30, 0x00,0x50,0x00,0x60, 0x00,0x50,0x00,0x90, 0x00,0x50,0x00,0xC0, 0x00,0x50,0x00,0xF0,
	0x00,0x50,0x20,0x00, 0x00,0x50,0x20,0x30, 0x00,0x50,0x20,0x60, 0x00,0x50,0x20,0x90, 0x00,0x50,0x20,0xC0, 0x00,0x50,0x20,0xF0,
	0x00,0x50,0x40,0x00, 0x00,0x50,0x40,0x30, 0x00,0x50,0x40,0x60, 0x00,0x50,0x40,0x90, 0x00,0x50,0x40,0xC0, 0x00,0x50,0x40,0xF0,
	0x00,0x50,0x60,0x00, 0x00,0x50,0x60,0x30, 0x00,0x50,0x60,0x60, 0x00,0x50,0x60,0x90, 0x00,0x50,0x60,0xC0, 0x00,0x50,0x60,0xF0,
	0x00,0x50,0x90,0x00, 0x00,0x50,0x90,0x30, 0x00,0x50,0x90,0x60, 0x00,0x50,0x90,0x90, 0x00,0x50,0x90,0xC0, 0x00,0x50,0x90,0xF0,
	0x00,0x50,0xB0,0x00, 0x00,0x50,0xB0,0x30, 0x00,0x50,0xB0,0x60, 0x00,0x50,0xB0,0x90, 0x00,0x50,0xB0,0xC0, 0x00,0x50,0xB0,0xF0,
	0x00,0x50,0xD0,0x00, 0x00,0x50,0xD0,0x30, 0x00,0x50,0xD0,0x60, 0x00,0x50,0xD0,0x90, 0x00,0x50,0xD0,0xC0, 0x00,0x50,0xD0,0xF0,
	0x00,0x50,0xF0,0x00, 0x00,0x50,0xF0,0x30, 0x00,0x50,0xF0,0x60, 0x00,0x50,0xF0,0x90, 0x00,0x50,0xF0,0xC0, 0x00,0x50,0xF0,0xF0,
	0x00,0xA0,0x00,0x00, 0x00,0xA0,0x00,0x30, 0x00,0xA0,0x00,0x60, 0x00,0xA0,0x00,0x90, 0x00,0xA0,0x00,0xC0, 0x00,0xA0,0x00,0xF0,
	0x00,0xA0,0x20,0x00, 0x00,0xA0,0x20,0x30, 0x00,0xA0,0x20,0x60, 0x00,0xA0,0x20,0x90, 0x00,0xA0,0x20,0xC0, 0x00,0xA0,0x20,0xF0,
	0x00,0xA0,0x40,0x00, 0x00,0xA0,0x40,0x30, 0x00,0xA0,0x40,0x60, 0x00,0xA0,0x40,0x90, 0x00,0xA0,0x40,0xC0, 0x00,0xA0,0x40,0xF0,
	0x00,0xA0,0x60,0x00, 0x00,0xA0,0x60,0x30, 0x00,0xA0,0x60,0x60, 0x00,0xA0,0x60,0x90, 0x00,0xA0,0x60,0xC0, 0x00,0xA0,0x60,0xF0,
	0x00,0xA0,0x90,0x00, 0x00,0xA0,0x90,0x30, 0x00,0xA0,0x90,0x60, 0x00,0xA0,0x90,0x90, 0x00,0xA0,0x90,0xC0, 0x00,0xA0,0x90,0xF0,
	0x00,0xA0,0xB0,0x00, 0x00,0xA0,0xB0,0x30, 0x00,0xA0,0xB0,0x60, 0x00,0xA0,0xB0,0x90, 0x00,0xA0,0xB0,0xC0, 0x00,0xA0,0xB0,0xF0,
	0x00,0xA0,0xD0,0x00, 0x00,0xA0,0xD0,0x30, 0x00,0xA0,0xD0,0x60, 0x00,0xA0,0xD0,0x90, 0x00,0xA0,0xD0,0xC0, 0x00,0xA0,0xD0,0xF0,
	0x00,0xA0,0xF0,0x00, 0x00,0xA0,0xF0,0x30, 0x00,0xA0,0xF0,0x60, 0x00,0xA0,0xF0,0x90, 0x00,0xA0,0xF0,0xC0, 0x00,0xA0,0xF0,0xF0,
	0x00,0xF0,0x00,0x00, 0x00,0xF0,0x00,0x30, 0x00,0xF0,0x00,0x60, 0x00,0xF0,0x00,0x90, 0x00,0xF0,0x00,0xC0, 0x00,0xF0,0x00,0xF0,
	0x00,0xF0,0x20,0x00, 0x00,0xF0,0x20,0x30, 0x00,0xF0,0x20,0x60, 0x00,0xF0,0x20,0x90, 0x00,0xF0,0x20,0xC0, 0x00,0xF0,0x20,0xF0,
	0x00,0xF0,0x40,0x00, 0x00,0xF0,0x40,0x30, 0x00,0xF0,0x40,0x60, 0x00,0xF0,0x40,0x90, 0x00,0xF0,0x40,0xC0, 0x00,0xF0,0x40,0xF0,
	0x00,0xF0,0x60,0x00, 0x00,0xF0,0x60,0x30, 0x00,0xF0,0x60,0x60, 0x00,0xF0,0x60,0x90, 0x00,0xF0,0x60,0xC0, 0x00,0xF0,0x60,0xF0,
	0x00,0xF0,0x90,0x00, 0x00,0xF0,0x90,0x30, 0x00,0xF0,0x90,0x60, 0x00,0xF0,0x90,0x90, 0x00,0xF0,0x90,0xC0, 0x00,0xF0,0x90,0xF0,
	0x00,0xF0,0xB0,0x00, 0x00,0xF0,0xB0,0x30, 0x00,0xF0,0xB0,0x60, 0x00,0xF0,0xB0,0x90, 0x00,0xF0,0xB0,0xC0, 0x00,0xF0,0xB0,0xF0,
	0x00,0xF0,0xD0,0x00, 0x00,0xF0,0xD0,0x30, 0x00,0xF0,0xD0,0x60, 0x00,0xF0,0xD0,0x90, 0x00,0xF0,0xD0,0xC0, 0x00,0xF0,0xD0,0xF0,
	0x00,0xF0,0xF0,0x00, 0x00,0xF0,0xF0,0x30, 0x00,0xF0,0xF0,0x60, 0x00,0xF0,0xF0,0x90, 0x00,0xF0,0xF0,0xC0, 0x00,0xF0,0xF0,0xF0,
	
	0x00,0x10,0x10,0x10, 0x00,0x20,0x20,0x20, 0x00,0x30,0x30,0x30, 0x00,0x40,0x40,0x40,
	0x00,0x50,0x50,0x50, 0x00,0x60,0x60,0x60, 0x00,0x70,0x70,0x70, 0x00,0x80,0x80,0x80,
	0x00,0x90,0x90,0x90, 0x00,0xA0,0xA0,0xA0, 0x00,0xB0,0xB0,0xB0, 0x00,0xC0,0xC0,0xC0,
	0x00,0xD0,0xD0,0xD0, 0x00,0xE0,0xE0,0xE0
};

int * hamx_array = (int *) (hamx_array_char);

uchar cmap_hamx[] = {
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x30, 0x00,0x00,0x00,0x60, 0x00,0x00,0x00,0x90, 0x00,0x00,0x00,0xC0, 0x00,0x00,0x00,0xF0,
	0x00,0x00,0x20,0x00, 0x00,0x00,0x20,0x30, 0x00,0x00,0x20,0x60, 0x00,0x00,0x20,0x90, 0x00,0x00,0x20,0xC0, 0x00,0x00,0x20,0xF0,
	0x00,0x00,0x40,0x00, 0x00,0x00,0x40,0x30, 0x00,0x00,0x40,0x60, 0x00,0x00,0x40,0x90, 0x00,0x00,0x40,0xC0, 0x00,0x00,0x40,0xF0,
	0x00,0x00,0x60,0x00, 0x00,0x00,0x60,0x30, 0x00,0x00,0x60,0x60, 0x00,0x00,0x60,0x90, 0x00,0x00,0x60,0xC0, 0x00,0x00,0x60,0xF0,
	0x00,0x00,0x90,0x00, 0x00,0x00,0x90,0x30, 0x00,0x00,0x90,0x60, 0x00,0x00,0x90,0x90, 0x00,0x00,0x90,0xC0, 0x00,0x00,0x90,0xF0,
	0x00,0x00,0xB0,0x00, 0x00,0x00,0xB0,0x30, 0x00,0x00,0xB0,0x60, 0x00,0x00,0xB0,0x90, 0x00,0x00,0xB0,0xC0, 0x00,0x00,0xB0,0xF0,
	0x00,0x00,0xD0,0x00, 0x00,0x00,0xD0,0x30, 0x00,0x00,0xD0,0x60, 0x00,0x00,0xD0,0x90, 0x00,0x00,0xD0,0xC0, 0x00,0x00,0xD0,0xF0,
	0x00,0x00,0xF0,0x00, 0x00,0x00,0xF0,0x30, 0x00,0x00,0xF0,0x60, 0x00,0x00,0xF0,0x90, 0x00,0x00,0xF0,0xC0, 0x00,0x00,0xF0,0xF0,
	0x00,0x50,0x00,0x00, 0x00,0x50,0x00,0x30, 0x00,0x50,0x00,0x60, 0x00,0x50,0x00,0x90, 0x00,0x50,0x00,0xC0, 0x00,0x50,0x00,0xF0,
	0x00,0x50,0x20,0x00, 0x00,0x50,0x20,0x30, 0x00,0x50,0x20,0x60, 0x00,0x50,0x20,0x90, 0x00,0x50,0x20,0xC0, 0x00,0x50,0x20,0xF0,
	0x00,0x50,0x40,0x00, 0x00,0x50,0x40,0x30, 0x00,0x50,0x40,0x60, 0x00,0x50,0x40,0x90, 0x00,0x50,0x40,0xC0, 0x00,0x50,0x40,0xF0,
	0x00,0x50,0x60,0x00, 0x00,0x50,0x60,0x30, 0x00,0x50,0x60,0x60, 0x00,0x50,0x60,0x90, 0x00,0x50,0x60,0xC0, 0x00,0x50,0x60,0xF0,
	0x00,0x50,0x90,0x00, 0x00,0x50,0x90,0x30, 0x00,0x50,0x90,0x60, 0x00,0x50,0x90,0x90, 0x00,0x50,0x90,0xC0, 0x00,0x50,0x90,0xF0,
	0x00,0x50,0xB0,0x00, 0x00,0x50,0xB0,0x30, 0x00,0x50,0xB0,0x60, 0x00,0x50,0xB0,0x90, 0x00,0x50,0xB0,0xC0, 0x00,0x50,0xB0,0xF0,
	0x00,0x50,0xD0,0x00, 0x00,0x50,0xD0,0x30, 0x00,0x50,0xD0,0x60, 0x00,0x50,0xD0,0x90, 0x00,0x50,0xD0,0xC0, 0x00,0x50,0xD0,0xF0,
	0x00,0x50,0xF0,0x00, 0x00,0x50,0xF0,0x30, 0x00,0x50,0xF0,0x60, 0x00,0x50,0xF0,0x90, 0x00,0x50,0xF0,0xC0, 0x00,0x50,0xF0,0xF0,
	0x00,0xA0,0x00,0x00, 0x00,0xA0,0x00,0x30, 0x00,0xA0,0x00,0x60, 0x00,0xA0,0x00,0x90, 0x00,0xA0,0x00,0xC0, 0x00,0xA0,0x00,0xF0,
	0x00,0xA0,0x20,0x00, 0x00,0xA0,0x20,0x30, 0x00,0xA0,0x20,0x60, 0x00,0xA0,0x20,0x90, 0x00,0xA0,0x20,0xC0, 0x00,0xA0,0x20,0xF0,
	0x00,0xA0,0x40,0x00, 0x00,0xA0,0x40,0x30, 0x00,0xA0,0x40,0x60, 0x00,0xA0,0x40,0x90, 0x00,0xA0,0x40,0xC0, 0x00,0xA0,0x40,0xF0,
	0x00,0xA0,0x60,0x00, 0x00,0xA0,0x60,0x30, 0x00,0xA0,0x60,0x60, 0x00,0xA0,0x60,0x90, 0x00,0xA0,0x60,0xC0, 0x00,0xA0,0x60,0xF0,
	0x00,0xA0,0x90,0x00, 0x00,0xA0,0x90,0x30, 0x00,0xA0,0x90,0x60, 0x00,0xA0,0x90,0x90, 0x00,0xA0,0x90,0xC0, 0x00,0xA0,0x90,0xF0,
	0x00,0xA0,0xB0,0x00, 0x00,0xA0,0xB0,0x30, 0x00,0xA0,0xB0,0x60, 0x00,0xA0,0xB0,0x90, 0x00,0xA0,0xB0,0xC0, 0x00,0xA0,0xB0,0xF0,
	0x00,0xA0,0xD0,0x00, 0x00,0xA0,0xD0,0x30, 0x00,0xA0,0xD0,0x60, 0x00,0xA0,0xD0,0x90, 0x00,0xA0,0xD0,0xC0, 0x00,0xA0,0xD0,0xF0,
	0x00,0xA0,0xF0,0x00, 0x00,0xA0,0xF0,0x30, 0x00,0xA0,0xF0,0x60, 0x00,0xA0,0xF0,0x90, 0x00,0xA0,0xF0,0xC0, 0x00,0xA0,0xF0,0xF0,
	0x00,0xF0,0x00,0x00, 0x00,0xF0,0x00,0x30, 0x00,0xF0,0x00,0x60, 0x00,0xF0,0x00,0x90, 0x00,0xF0,0x00,0xC0, 0x00,0xF0,0x00,0xF0,
	0x00,0xF0,0x20,0x00, 0x00,0xF0,0x20,0x30, 0x00,0xF0,0x20,0x60, 0x00,0xF0,0x20,0x90, 0x00,0xF0,0x20,0xC0, 0x00,0xF0,0x20,0xF0,
	0x00,0xF0,0x40,0x00, 0x00,0xF0,0x40,0x30, 0x00,0xF0,0x40,0x60, 0x00,0xF0,0x40,0x90, 0x00,0xF0,0x40,0xC0, 0x00,0xF0,0x40,0xF0,
	0x00,0xF0,0x60,0x00, 0x00,0xF0,0x60,0x30, 0x00,0xF0,0x60,0x60, 0x00,0xF0,0x60,0x90, 0x00,0xF0,0x60,0xC0, 0x00,0xF0,0x60,0xF0,
	0x00,0xF0,0x90,0x00, 0x00,0xF0,0x90,0x30, 0x00,0xF0,0x90,0x60, 0x00,0xF0,0x90,0x90, 0x00,0xF0,0x90,0xC0, 0x00,0xF0,0x90,0xF0,
	0x00,0xF0,0xB0,0x00, 0x00,0xF0,0xB0,0x30, 0x00,0xF0,0xB0,0x60, 0x00,0xF0,0xB0,0x90, 0x00,0xF0,0xB0,0xC0, 0x00,0xF0,0xB0,0xF0,
	0x00,0xF0,0xD0,0x00, 0x00,0xF0,0xD0,0x30, 0x00,0xF0,0xD0,0x60, 0x00,0xF0,0xD0,0x90, 0x00,0xF0,0xD0,0xC0, 0x00,0xF0,0xD0,0xF0,
	0x00,0xF0,0xF0,0x00, 0x00,0xF0,0xF0,0x30, 0x00,0xF0,0xF0,0x60, 0x00,0xF0,0xF0,0x90, 0x00,0xF0,0xF0,0xC0, 0x00,0xF0,0xF0,0xF0,
	0x00,0x10,0x10,0x10, 0x00,0x20,0x20,0x20, 0x00,0x30,0x30,0x30, 0x00,0x40,0x40,0x40, 0x00,0x50,0x50,0x50, 0x00,0x60,0x60,0x60,
	0x00,0x70,0x70,0x70, 0x00,0x80,0x80,0x80, 0x00,0x90,0x90,0x90, 0x00,0xA0,0xA0,0xA0, 0x00,0xB0,0xB0,0xB0, 0x00,0xC0,0xC0,0xC0,
	0x00,0xD0,0xD0,0xD0, 0x00,0xE0,0xE0,0xE0
};


int scalecmapY = FALSE;
float adat_gamma = 1.0;
float adat_distort = 1.0;

/*
 * 
 * Nieuwe versie:
 * 
 * 32 helderheden	Y			 15 direct te bereiken (zwart & wit zijn specials)
 * 16 kleuren		H ue		
 * 7 intensiteiten	S aturation
 * 
 * Totaal 3584 'verschillende' kleuren. Eerste 512 kleuren vrij.
 * 
 * 
 */


#define NEW_TAN_COLOR(offset)\
	\
	nh = (rect[1 + offset] / 16.0) + 0.5;\
	ny = (31.0 * rect[2 + offset] / 255.0) + 0.5;\
	ns = ((rect[3 + offset] - 80) / 16.0) + 0.5;\
	\
	/* h is cyclish */\
	nh &= 0xf;\
	/* s moet nog even geclipped worden */\
	if (ns < 0) ns = 0;\
	else if (ns > 6) ns = 6;\

#define EVALUATE_TAN_old(h, y, s, newcol)\
	\
	/* hys -> kunnen we zetten met behulp van newcol */\
	\
	if (minerror) {\
		int q;\
		error = 0;\
		/* Hue is cyclisch */\
		\
			/* volgende regels zorgen ervoor dat bij om en om dither laagste waarde stabiel is\
			* om die reden moeten cs/ns en ch/nh even zwaar blijven wegen voor errorbepaling\
			*/\
		q = h - ch;\
		if (q > 0) error++;\
		else if (q == -15) error++;\
		\
		q = ABS(h - ch);\
		if (q > 8) q = 16 - q;\
		error += (cs + 1) * q;\
		\
		q = ABS(h - nh);\
		if (q > 8) q = 16 - q;\
		error += (ns + 1) * q;\
		\
		error >>= 1;\
		error += ABS(y - cy) + (ABS(y - ny) >> 1);\
		error += 2 * (ABS(s - cs) + ABS(s - ns));\
			/* volgende regel zorgt ervoor dat bij om en om dither laagste waarde stabiel is */\
		if (s - cs > 0) error++;\
		\
		if (error < minerror) {\
			minerror = error;\
			col = newcol;\
			fh = h;\
			fy = y;\
			fs = s;\
		}\
	}\

#define EVALUATE_TAN(h, y, s, newcol)\
	\
	/* hys -> kunnen we zetten met behulp van newcol */\
	\
	if (minerror) {\
		int q;\
		error = 0;\
		/* Hue is cyclisch */\
		\
			/* volgende regels zorgen ervoor dat bij om en om dither laagste waarde stabiel is\
			* om die reden moeten cs/ns en ch/nh even zwaar blijven wegen voor errorbepaling\
			*/\
		q = h - ch;\
		if (q > 0) error++;\
		else if (q == -15) error++;\
		if (cs) {\
			q = ABS(h - ch);\
			if (q > 8) q = 16 - q;\
			error += q;\
		}\
		if (ns) {\
			q = ABS(h - nh);\
			if (q > 8) q = 16 - q;\
			error += q;\
		}\
		error += ABS(y - cy) + (ABS(y - ny) >> 1);\
		error += 2 * (ABS(s - cs) + ABS(s - ns));\
			/* volgende regel zorgt ervoor dat bij om en om dither laagste waarde stabiel is */\
		if (s - cs > 0) error++;\
		\
		if (error < minerror) {\
			minerror = error;\
			col = newcol;\
			fh = h;\
			fy = y;\
			fs = s;\
		}\
	}\

#define YH_tan_start		0		/* + 15 * 8 */
#define YS_tan_start		120		/* + 15 * 4 */
#define Y_tan_start			180		/* + 32 */
#define H_tan_start			212		/* + 16 */
#define S_tan_start			228		/* + 7 */
#define HS_tan_start		235		/* + 16 ?? */
#define FREE_tan_start		251		/* + 4 ?? */

void converttotanx(ibuf)
struct ImBuf *ibuf;
{
	/* 
	 * l? staat voor last		(echt gezette pixel)
	 * c? staat voor current	(wil ik zetten)
	 * n? staat voor next		(volgende pixel die ik moet zetten)
	 * f? staat voor final		(pixel die ik ga zetten)
	 */

	int cy, ch, cs, ly, lh, ls, dy, dh, ds, nh, ny, ns, fh, fy, fs, ty, t, col, type, step, first;
	int i, error, minerror;
	uchar *rect;
	
	first = TRUE;
	
	for (step = 0 ; step < 2 ; step ++){
		rect =  (uchar *) ibuf->rect;
		rect += 4 * step;
		i = ((ibuf->x * ibuf->y) + 2 - step - 1) / 2;

		ly = 255;
		lh = ls = 0;
		
		NEW_TAN_COLOR(0)

		for ( ; i > 0; i--){
			ch = nh;
			cy = ny;
			cs = ns;
			
			if (i > 1) {
				NEW_TAN_COLOR(8)
			}
			
			if ((ns - cs) > 1 && (ns - ls) > 1) ch = nh; /* alvast vooruit werken */

			dh = ch - lh;
			dy = cy - ly;
			ds = cs - ls;
			
			if (dh | dy | ds) {
				/* mogelijke optimaliseringen:
				 * zwart & wit afvangen
				 */
				
				/*
				 * verdere verbeteringen:
				 * kleuren anders verdelen zodat de kleuren exact op de rgb componenten komen
				 * te vallen. magenta->rood en cyaan->groen heeft dan 1 tussenkleur,  de andere
				 * overgangen dan telkens 2.
				 */
				
				/* maar een variable verandert */
				
				if (dy == 0 && ds == 0) {
					col = H_tan_start + ch;
					lh = ch;
				} else if (dh == 0 && ds == 0) {
					col = Y_tan_start + cy;
					ly = cy;
				} else if (dy == 0 && dh == 0) {
					col = S_tan_start + cs;
					ls = cs;
				} else {
					/* we lopen alle mogelijkheden af */
					minerror = 0x7fffffff;
					
					if (dy) {
						ty = (15.0 * rect[2] / 255.0) + 0.5;\
						ty += ty;
						if (ty == 0) ty = 2;
						
						if (dh) EVALUATE_TAN((ch & ~1), ty, ls,  YH_tan_start + (8 * ((ty - 2) >> 1)) + (ch >> 1));
						if (ds) {
							t = ((rect[3] - 80) / 32.0) + 0.5;\
							if (t < 0) t = 0;
							else if (t > 3) t = 3;
							EVALUATE_TAN(lh, ty, t + t,  YS_tan_start + (4 * ((ty - 2) >> 1)) + t);
						}
					}
					
					if (dy) EVALUATE_TAN(lh, cy, ls, Y_tan_start + cy);
					if (dh) EVALUATE_TAN(ch, ly, ls, H_tan_start + ch);
					if (ds) EVALUATE_TAN(lh, ly, cs, S_tan_start + cs);
					
					/* bij niet zo felle kleuren is de HS niet zo belangrijk */
					if (fs < 4) minerror = (minerror >> 1) + (minerror >> 2);
					
					if (cs < 4) {
						EVALUATE_TAN((ch & ~1), ly, 2, HS_tan_start + (ch >> 1));
					} else {
						EVALUATE_TAN((ch & ~1), ly, 4, HS_tan_start + 8 + (ch >> 1));
					}
					
					lh = fh;
					ly = fy;
					ls = fs;
				}
			}
/*
			if (rect[0] != 255) {
				printf("%2d %2d %2d\n", lh, ly, ls);
				printf("%2d %2d %2d %3d\n\n", ch, cy, cs, col);
			}
*/
			rect[1] = (lh * 16.0) + 0.5;
			rect[2] = ((ly * 255.0) / 31.0) + 0.5;
			rect[3] = (ls * 16.0) + 0.5 + 80.0;
			
			rect[0] = col;

			if (step == 0) {
				/* error diffusion */
				
				if (first == TRUE) first = FALSE;
				else if (i != 1) {
					dh = (rect[1] - ((255 * lh) / 16)) / 2;
					dy = (rect[2] - ((255 * ly) / 31)) / 2;
					ds = (rect[3] - 80 - ((255 * ls) / 16)) / 2;
					
					rect[-3] += dh;
					rect[5] += dh;
					
					t = rect[-2] + dy;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[-2] = t;
					
					t = rect[6] + dy;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[6] = t;
					
					t = rect[-1] + ds;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[-1] = t;
					
					t = rect[7] + ds;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[7] = t;
				}
			}

			rect += 8;
		}
	}
}


short dec_tanx(ibuf)
struct ImBuf * ibuf;
{
	int todo,i;
	int j,step,col;
	uint *rect;
	int y, s, h, ny, ns, nh;
	
	for (step = 0 ; step < 2 ; step ++){
		rect = ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + 2 - step - 1) / 2;
		
		y = 0;
		s = h = 0;
		
		for (;todo > 0; todo --){
			col = rect[0] & 0xff;
			
			*rect = 0;
			if (col >= FREE_tan_start) {
				col -= FREE_tan_start;
			} else if (col >= S_tan_start) {
				col -= S_tan_start;
				s = col;
			} else if (col >= H_tan_start) {
				col -= H_tan_start;
				h = col;
			} else if (col >= Y_tan_start) {
				col -= Y_tan_start;
				y = col;
			} else if (col >= YS_tan_start) {
				col -= YS_tan_start;
				y = col >> 2;
				y = 2 + 2 * y;
				s = (col & 0x3) << 1;
			} else if (col >= YH_tan_start) {
				col -= YH_tan_start;
				y = col >> 3;
				y = 2 + 2 * y;
				h = (col & 0x7) << 1;
			}
			
			nh = (h * 16.0) + 0.5;
			ny = ((y * 255.0) / 31.0) + 0.5;
			ns = (s * 16.0) + 0.5 + 80.0;

			*rect = (nh << 16) + (ny << 8) + ns;
			
			rect += 2;
		}
	}
	return(1);
}


void filteruv(ibuf)
struct ImBuf *ibuf;
{
	uchar *point;
	short x,y,skip;

	point = (uchar *)ibuf->rect;
	x = ibuf->x;
	y = ibuf->y;
	
	skip = x << 2;

	for (;y > 0; y--){
		filtrow(point + 1, x);
		filtrow(point + 3, x);
		point += skip;
	}

	
/*	point = (uchar *)ibuf->rect;
	x = ibuf->x;
	y = ibuf->y;

	for (;x>0;x--){
		filtcolum(point + 1, y, skip);
		filtcolum(point + 3, y, skip);
		point += 4;
	}
*/}

void tan_add_dit4(struct ImBuf * ibuf, short ofs)
{
	short x, y;
	uchar * rect;
	short * add;
	static short dit_[] = 	{
		0, 14, 1, 15, 10, 4, 11, 5, 2, 12, 3, 13, 8, 6, 9, 7 };
	static short dit__[] = 	{
		-7, 7, -6, 8, 3, -3, 4, -2, -5, 5, -4, 6, 1, -1, 2, 0 };
	static short dit[] = 	{
		-8, 6, -7, 7, 2, -4, 3, -3, -6, 4, -5, 5, 0, -2, 1, -1 };
	
	rect= (uchar *)ibuf->rect;
	rect +=ofs;

	for(y=ibuf->y;y>0;y--){
		add = &dit[4 * (y & 3)];
		for (x = ibuf->x; x > 0; x--){
			*rect += add[x & 3];
			rect += 4;
		}
	}
}

void tan_add_dit2(struct ImBuf * ibuf, short ofs)
{
	short x, y, pix, add1, add2, dit_[] = {0, 4, 6, 2}, dit[] = {-3, 1, 3, -1};
	uchar *rect;

	rect = (uchar *) ibuf->rect;
	rect += ofs;

	for (y = ibuf->y; y > 0; y--){

		if (y & 1){
			add1 = dit[0];
			add2 = dit[1];
		} else {
			add1 = dit[2];
			add2 = dit[3];
		}
		
		for (x = ibuf->x; x > 0; x--){
			pix = *rect;
			if (x & 1) pix += add1;
			else pix += add2;
			
			if (pix & 0x100) {
				if (pix < 0) pix = 0;
				else pix = 255;
			}

			*rect = pix;
			rect += 4;
		}
	}
}



/*
 *  YUVX
 * 
 * 17 stappen in y, 15 stappen in u & v
 * 
 * y = 0 -> u = 0
 * y = 16 -> v = 0
 * 
 * y kan telkens direct gezet worden. Daarnaast kan grofweg de u & v gezet worden. Als y
 * al goet staat, kunnen u & v nauwkeurig gezet worden.
 * 
 * Alle 17 grijstinten kunnen direct gezet worden.
 * 
 * coderings tabel:
 * 
 * 000 - 104	15y * 7u = 105
 * 105 - 209	15y * 7v = 105
 * 210 - 217	8 tussenliggende u's = 8
 * 218 - 225	8 tussenliggende v's = 8
 * 226 - 242	17 grijswaardes
 * 243 - 255	13 keer alleen y veranderen
 * 
 */


#define YB_yrb_start	0
#define YR_yrb_start	105
#define B_yrb_start		210
#define R_yrb_start		218
#define GREY_yrb_start	226
#define Y_yrb_start		243


void converttoyuvx(ImBuf * ibuf)
{
	short y, b, r, ly, lb, lr, dy, db, dr, t, col, type, step, first;
	int i;
	uchar *rect;
	
	first = TRUE;
	
	for (step = 0 ; step < 2 ; step ++){
		rect =  (uchar *) ibuf->rect;
		rect += 4 * step;
		i = ((ibuf->x * ibuf->y) + 2 - step - 1) / 2;

		type = col = 0;
		
		ly = 255;
		lb = lr = 7;
		
		col = 0;
		
		for ( ; i > 0; i--){
			b = (14.0 * rect[1] / 255.0) + 0.5;
			y = (16.0 * rect[2] / 255.0) + 0.5;
			r = (14.0 * rect[3] / 255.0) + 0.5;
			
			db = b - lb;
			dy = y - ly;
			dr = r - lr;

			if (db | dy | dr) {
				ly = y;				/* always */
				
				if (((b == 7) && (r == 7)) || (y == 0) || (y == 16)) {	/* GREY */
					col = GREY_yrb_start + y;
					lb = lr = 7;
				} else {
					/* wie gaat er voorrang krijgen, b-y of r-y ? */
					
					type = 0;
					
					if (db | dr) {
						db = ABS(db);
						dr = ABS(dr);
					
						if (db > dr) type = 'b';
						else type = 'r';
					}
					
					if (type == 0) {
						/* niet alle y-waardes kunnen gezet worden zonder
						 * ook r of b te zetten (te weinig codes).
						 * We gaan kijken of dat misschien zonder probleem kan.
						 */
						 
						 if (r & 1) type = 'r';
						 else if (b & 1) type = 'b';
								/* Helaas. Heel donker & heel licht hebben pech */
						 else if (y == 1 || y == 15) type = 'b';
					}
					
					if (type == 0) {				/* alleen y moet gezet worden */
						col = Y_yrb_start + y - 2;
					} else if (type == 'b') {
						if (dy || (b & 1)) {		/* als y gezet moet worden, of b = oneven */
							/* welke waarde ligt het dichtst in de buurt ? */
							t = (6 * rect[1] / 255.0) + 0.5;	/* t wordt een waarde tussen 0 & 6 */
							lb = (2 * t) + 1;
							col = YB_yrb_start + (7 * (y - 1)) + t; /* y loopt van 1 - 15 */
						} else {
							lb = b;
							col = B_yrb_start + (b / 2);
						}
					} else {
						if (dy || (r & 1)) {
							t = (6 * rect[3] / 255.0) + 0.5;
							lr = (2 * t) + 1;
							col = YR_yrb_start + (7 * (y - 1)) + t;
						} else {
							lr = r;
							col = R_yrb_start + (r / 2);
						}
					}
				}
			}
			
			if (step == 0) {
				/* error diffusion */
				
				if (first == TRUE) first = FALSE;
				else if (i != 1) {
					db = (rect[1] - ((255 * lb) / 14)) / 2;
					dr = (rect[3] - ((255 * lr) / 14)) / 2;
					
					t = rect[-3] + db;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[-3] = t;
					
					t = rect[5] + db;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[5] = t;
					
					t = rect[-1] + dr;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[-1] = t;
					
					t = rect[7] + dr;
					if (t & 0x100) {
						if (t < 0) t = 0;
						else t = 255;
					}
					rect[7] = t;
				}
			}

			rect[3] = col;
			rect += 8;
		}
	}
}


void atan_space(ImBuf * ibuf)
{
	int x, y;
	double u, v, t, l;
	uchar * rect;
	
	rect = (uchar *) ibuf->rect;
	for (y = ibuf->y; y > 0 ; y--) {
		for (x = ibuf->x; x > 0 ; x--) {
			u = rect[1] - 128;
			v = rect[3] - 128;

			t = 128.0 * ((atan2(u, v) / M_PI) + 1.0);
			l = 256.0 * sqrt(((u * u) + (v * v)) / 32768.0);
			
			/* l loopt van 0 -> 193 en moet uiteindelijk een bereik
			 * van (7 - 1) * 16  = 96 krijgen. (komt dat even mooi uit)
			 */
			
			l = 193.0 * pow(l / 193.0 , 1.0 / 1.3);
			l = (l / 2.0) + 80.0;
			
			if (t > 255.0) t = 255.0;
			if (l > 255.0) l = 255.0;			
						
			rect[1] = t;
			rect[3] = l;
			rect += 4;
		}
	}
}


void tan_space(ImBuf * ibuf)
{
	int x, y;
	double u, v, t, l;
	uchar * rect;
	
	rect = (uchar *) ibuf->rect;
	for (y = ibuf->y; y > 0 ; y--) {
		for (x = ibuf->x; x > 0 ; x--) {
			t = M_PI * ((rect[1] / 128.0) - 1.0);

			l = 2.0 * (rect[3] - 80.0);
			
			/* l loopt nu tussen 0 -> 193 
			 * Gamma 2.0 over de kleurverzadiging
			 */

			l = 193.0 * pow(l / 193.0 , 1.3);
			/*l = l * l / 193.0;*/

			/* scalen met 1/2 SQRT(2) */
			l = M_SQRT1_2 * l;
			
			u = (l * sin(t)) + 128.0;
			v = (l * cos(t)) + 128.0;

			if (u > 255.0) u = 255.0;
			if (v > 255.0) v = 255.0;			
			if (u < 0.0) u = 0.0;
			if (v < 0.0) v = 0.0;			
			
			rect[1] = u;
			rect[3] = v;
			rect += 4;
		}
	}
}

void nix()
{
	double l;
	
			/* .8343227 = bijna gamma 1.3 */
			/* .5079365 */
			
			/* 0 -> 193.0 */
			l = 6.0 * (1.0 - (l / 193.0));
			/* 6 -> 0 */
			l = 1.0 - ((1.0 - pow(.7, l)) / (1.0 - pow(.7, 6)));
			/* 0 -> 1.0 */
			l *= 193.0;
			/* 0 -> 193.0 */

}

void yrb_add_dit4(ImBuf * ibuf, short ofs)
{
	short x,y,pix,and;
	uchar *rect;
	short dit[] = {-8, 0, -6, 2, 4, -4, 6, -2, -5, 3, -7, 1, 7, -1, 5, -3}, * add;

	rect= (uchar *)ibuf->rect;
	rect +=ofs;

	for (y = ibuf->y; y > 0; y--){
		add = &dit[4 * (y & 3)];
		for(x = ibuf->x; x > 0; x--){
			pix = *rect + add[x & 3];
			
			if (pix & 0x100) {
				if (pix < 0) pix = 0;
				else pix = 255;
			}
			
			*rect = pix;
			rect += 4;
		}
	}
}

void yrb_add_dit2(struct ImBuf * ibuf, short ofs)
{
	short x, y, pix, add1, add2, dit[] = {-6, 2, 6, -2};
	uchar *rect;

	rect = (uchar *) ibuf->rect;
	rect += ofs;

	for (y = ibuf->y; y > 0; y--){

		if (y & 1){
			add1 = dit[0];
			add2 = dit[1];
		} else {
			add1 = dit[2];
			add2 = dit[3];
		}
		
		for (x = ibuf->x; x > 0; x--){
			pix = *rect;
			if (x & 1) pix += add1;
			else pix += add2;
			
			if (pix & 0x100) {
				if (pix < 0) pix = 0;
				else pix = 255;
			}

			*rect = pix;
			rect += 4;
		}
	}
}


void convhamx(ibuf, coltab, deltab)
struct ImBuf *ibuf;
uchar coltab[][4];
short *deltab;
{
	short r,g,b,lr,lg,lb,dr,dg,db,col,fout,type,step;
	int i;
	uchar *rect;

	/*
		b 	= 0000 xxxx
		g	= 0001 xxxx
		r	= 0010 xxxx
		cmap  >=  48
	*/

	for (step = 0 ; step < 2 ; step ++){
		rect =  (uchar *) ibuf->rect;
		rect += 4*step;
		i = ((ibuf->x * ibuf->y) + 2 - step - 1) / 2;

		lb = coltab[0][1];
		lg = coltab[0][2];
		lr = coltab[0][3];
		type = col = 0;

		for ( ;i>0;i--){
			b = rect[2] >> 4;
			g = rect[1] >> 4;
			r = rect[0] >> 4;

			if ((b-lb) | (g-lg) | (r-lr)){
				col = ((b<<8) + (g<<4) + r) << 1;
				fout = deltab[col + 1];
				col = deltab[col];
				type = 0;
				dr = quadr[lr-r] ;
				dg = quadr[lg-g] ;
				db = quadr[lb-b];

				if ((dr+dg)<=fout) {
					fout = dr+dg ;
					type = 1;
				}
				if ((dg+db)<=fout) {
					fout = dg+db;
					type = 2;
				}
				if ((dr+db)<=fout) {
					fout = dr+db;
					type = 4;
				}

				switch(type){
				case 1:
					lb = b ;
					col = b;
					break;
				case 4:
					lg = g ;
					col = g+16;
					break;
				case 2:
					lr = r ;
					col = r + 32;
					break;
				default:
					/*printf("%04x %5d %5d  ", (b<<8) + (g<<4) + r, col, fout);*/
					
					lb = coltab[col][1];
					lg = coltab[col][2];
					lr = coltab[col][3];
					/*printf("%01x%01x%01x %01x%01x%01x\n", b, g, r, lb, lg, lr);*/
					col += 48;
				}
			}
			rect[3] = col;
			rect += 8;
		}
	}
}


short dec_c233_rect(ibuf,body,steps)
struct ImBuf * ibuf;
uchar *body;
int steps;
{
	uchar i;
	int todo;
	uint *rect,j,step;

	for (step = 0 ; step < steps ; step ++){
		rect = ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + steps - step - 1) / steps;
		while (todo>0){
			i = *body++;

			if (i & 128){			/* fill */
				if (i==128) continue;	/* nop  */
				i = 257-i;
				todo -= i;
				j = *(body++) | 0x100;
				do{
					*rect = j;
					rect += steps;
				}while (--i);
			} else{				/* copy */
				i++;
				todo -= i;
				do{
					*rect = *(body++) | 0x100;
					rect += steps;
				}while (--i);
			}
		}
		if (todo) return (0);
	}
	return(1);
}

short dec_c233(ibuf,body,steps)
struct ImBuf * ibuf;
uchar *body;
int steps;
{
	uchar i;
	int todo;
	short *rect,j,step;

	for (step = 0 ; step < steps ; step ++){
		rect = (short *) ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + steps - step - 1) / steps;
		while (todo>0){
			i = *body++;

			if (i & 128){			/* fill */
				if (i==128) continue;	/* nop  */
				i = 257-i;
				todo -= i;
				j = *(body++) | 0x100;
				do{
					*rect = j;
					rect += steps;
				}while (--i);
			} else{				/* copy */
				i++;
				todo -= i;
				do{
					*rect = *(body++) | 0x100;
					rect += steps;
				}while (--i);
			}
		}
		if (todo) return (0);
	}
	return(1);
}


short dec_and_or_rect(ImBuf * ibuf, uchar * body, short * and_or, int first)
{
	int todo, i;
	int j, step, col;
	uint *rect;

	for (step = 0 ; step < 2 ; step ++){
		rect = ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + 2 - step - 1) / 2;
		
		col = first;
		
		while (todo>0){
			i = *body++;

			if (i & 128){			/* fill */

				i = 257-i;
				todo -= i;
				j = *(body++);

				col = (col & and_or[j]) | and_or[j + 256];

				do{
					*rect = col;
					rect += 2;
				}while (--i);
			} else{				/* copy */
				i++;
				todo -= i;

				do{
					j = *(body++);
					col = (col & and_or[j]) | and_or[j + 256];
					*rect = col;
					rect += 2;
				}while (--i);
			}
		}
		if (todo) return (0);
	}
	return(1);
}


short dec_and_or_short(ImBuf * ibuf, uchar * body, short * and_or, int first)
{
	int todo, i;
	int j, step, col;
	short *rect;

	for (step = 0 ; step < 2 ; step ++){
		rect = (short *) ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + 2 - step - 1) / 2;
		
		col = first;
		
		while (todo>0){
			i = *body++;

			if (i & 128){			/* fill */

				i = 257-i;
				todo -= i;
				j = *(body++);
				
				col = (col & and_or[j]) | and_or[j + 256];

				do{
					*rect = col;
					rect += 2;
				}while (--i);
			} else {				/* copy */
				i++;
				todo -= i;

				do{
					j = *(body++);
					/*and_or[511] = rect[-first];*/
					* rect = col = (col & and_or[j]) | and_or[j + 256];
					rect += 2;
				}while (--i);
			}
		}
		if (todo) return (0);
	}
	return(1);
}


short dec_hamx(ibuf,body,cmap)
struct ImBuf * ibuf;
uchar *body;
int cmap[];
{
	int todo,i;
	int j,step,col;
	uint *rect;

	for (step = 0 ; step < 2 ; step ++){
		rect = ibuf->rect;
		rect += step;
		todo = (ibuf->x * ibuf->y + 2 - step - 1) / 2;
		col = cmap[0];
		while (todo>0){
			i = *body++;

			if (i & 128){			/* fill */

				i = 257-i;
				todo -= i;
				j = *(body++);

				col = ((col & hamx_array[j]) | hamx_array[j + 256]);

				do{
					*rect = col;
					rect += 2;
				}while (--i);
			} else{				/* copy */
				i++;
				todo-=i;

				do{
					j = *(body++);
					*rect = col = ((col & hamx_array[j]) | hamx_array[j + 256]);
					rect += 2;
				}while (--i);
			}
		}
		if (todo) return (0);
	}
	return(1);
}


struct ImBuf *loadanim(int *iffmem, int flags)
{
	int chunk, totlen, len, *mem, cmaplen = 0;
	uint *cmap;
	uchar *body = 0;
	struct Adat adat;
	struct ImBuf *ibuf=0;
	extern float rgb_to_bw[4][4];
	static int first_tanx = TRUE;
	static int is_flipped = FALSE;
	
	mem=iffmem;
	if (GET_ID(mem) != FORM) return (0);
	if (GET_ID(mem + 2) != ANIM) return (0);
	totlen= (GET_BIG_LONG(mem + 1) + 1) & ~1;
	mem += 3;
	totlen -= 4;
	adat.w = 0;
	adat.xorig = 0;
	adat.yorig = 0;
	adat.gamma = adat_gamma;
	adat.distort = adat_distort;
	
	while(totlen > 0){
		chunk = GET_ID(mem);
		len = (GET_BIG_LONG(mem + 1) + 1) & ~1;
		mem += 2;

		totlen -= len+8;
		switch (chunk){
		case ADAT:
			if (len > sizeof(struct Adat)){
				memcpy(&adat,mem,sizeof(struct Adat));
			} else{
				memcpy(&adat,mem,len);
			}
			adat.w = BIG_SHORT(adat.w);
			adat.h = BIG_SHORT(adat.h);
			adat.type = BIG_SHORT(adat.type);
			adat.xorig = BIG_SHORT(adat.xorig);
			adat.yorig = BIG_SHORT(adat.yorig);
			break;
		case CMAP:
			cmap = (uint *) mem;
			cmaplen = len;
			break;
		case BODY:
			body = (uchar *) mem;
			break;
		}
		mem = (int *)((uchar *)mem +len);
	}

	if (body == 0) return (0);
	if (adat.w == 0) return (0);

	adat_gamma = adat.gamma;
	adat_distort = adat.distort;

	if (flags & IB_test) ibuf=allocImBuf(adat.w, adat.h, 24, 0, 0);
	else ibuf=allocImBuf(adat.w, adat.h, 24, IB_rect, 0);
	if (ibuf==0) return (0);

	ibuf->ftype = (Anim | adat.type);
	ibuf->xorig = adat.xorig;
	ibuf->yorig = adat.yorig;
	ibuf->flags = flags;
	
	if (cmaplen){
		ibuf->cmap = malloc(cmaplen);
		memcpy(ibuf->cmap, cmap, cmaplen);
		ibuf->maxcol = cmaplen >> 2;
	}

	if (flags & IB_test){
		if (flags & IB_freem) free(iffmem);
		return(ibuf);
	}

	switch (adat.type){
	case C233:
		if (flags & IB_word){
			if (dec_c233(ibuf,body,2) == 0){
				freeImBuf(ibuf);
				ibuf = 0;
			}
		} else {
			if (dec_c233_rect(ibuf, body, 2) == 0){
				freeImBuf(ibuf);
				ibuf = 0;
			}
		}
		break;
	case YUVX:
		ibuf->cmap = yuv_cmap;
		ibuf->mincol = 256;
		ibuf->maxcol = 4096;
		
		if (flags & IB_word){
			dec_and_or_short(ibuf, body, yuv_and_or, 0x888);
		} else {
			dec_and_or_rect(ibuf, body, yuv_and_or, 0x888);
			if ((flags & IB_cmap) == 0) applycmap(ibuf);
			if ((flags & IB_ttob) == 0) flipy(ibuf);
		}		

		break;
	case TANX:
		if (first_tanx) {
			ImBuf * tbuf;
			
			/* Convert cmap to RGB with current settings */
			tbuf = allocImBuf(4096, 1, 24, 0, 0);
			tbuf->rect = tan_cmap;
			tan_space(tbuf);
			cspace(tbuf, yuvrgb);
			gamwarp(tbuf, adat_gamma);
			freeImBuf(tbuf);
			
			first_tanx = FALSE;
		}

		ibuf->cmap = tan_cmap;
		ibuf->mincol = 512;
		ibuf->maxcol = 4096;
		
		if (flags & IB_word){
			dec_and_or_short(ibuf, body, tan_and_or, 0x200);
		} else if (1) {
			dec_and_or_rect(ibuf, body, tan_and_or, 0x200);
			if ((flags & IB_cmap) == 0) applycmap(ibuf);
			if ((flags & IB_ttob) == 0) flipy(ibuf);
		} else {
			dec_c233_rect(ibuf, body, 2);
			dec_tanx(ibuf);

			tan_space(ibuf);
			cspace(ibuf, yuvrgb);
			gamwarp(ibuf, adat.gamma);

			if ((flags & IB_ttob) == 0) flipy(ibuf);
		}

		break;
	case HAMX:
		if (flags & IB_rect){
			if (!is_flipped) {
				int i;
				uint * t;
				t = (uint *) hamx_array_char;
				
				for (i = 0; i < sizeof(hamx_array_char) / sizeof(int) ; i++) {
					t[i] = SWAP_LONG(t[i]);
				}
				
				t = (uint *) cmap_hamx;
			
				for (i = 0; i < sizeof(cmap_hamx) / sizeof(int) ; i++) {
					t[i] = SWAP_LONG(t[i]);
				}
				
				is_flipped= TRUE;
			}

			if (dec_hamx(ibuf,body,cmap_hamx) == 0){
				freeImBuf(ibuf);
				ibuf = 0;
			}
			if (flags & IB_ttob) flipy(ibuf);
		}
		break;
	default:
		freeImBuf(ibuf);
		ibuf = 0;
	}
	
	if (scalecmapY) {
	    ibuf->x /= 2;
	    scalefastImBuf(ibuf, ibuf->x, ibuf->y * 2);
	    ibuf->x *=2;
	}

	if (flags & IB_freem) free(iffmem);

	return (ibuf);
}


uchar *makebody_anim(bytes,buf,rect)
register uchar *buf;
register uchar *rect;
int bytes;
{
	register uchar last,this;
	register int copy;
	register uchar *rectstart,*temp;

	bytes--;
	rectstart = rect;
	last = *rect++;
	this = *rect++;
	copy = last^this;
	while (bytes>0){
		if (copy){
			do{
				last = this;
				this = *rect++;
				if (last == this){
					if (this == rect[-3]){		/* drie dezelfde? */
						bytes --;					/* bytes goed zetten */
						break;
					}
				}
			}while (--bytes != 0);

			copy = rect-rectstart;
			copy --;
			if (bytes) copy -= 2;

			temp = rect;
			rect = rectstart;

			while (copy){
				last = copy;
				if (copy>MAXDAT) last = MAXDAT;
				copy -= last;
				*buf++ = last-1;
				do{
					*buf++ = *rect++;
				}while(--last != 0);
			}
			rectstart = rect;
			rect = temp;
			last = this;

			copy = FALSE;
		} else {
			while (*rect++ == this){		/* zoek naar eerste afwijkende byte */
				if (--bytes == 0) break;	/* of einde regel */
			}
			rect --;
			copy = rect-rectstart;
			rectstart = rect;
			bytes --;
			this = *rect++;

			while (copy){
				if (copy>MAXRUN){
					*buf++ = -(MAXRUN-1);
					*buf++ = last;
					copy -= MAXRUN;
				} else {
					*buf++ = -(copy-1);
					*buf++ = last;
					break;
				}
			}
			copy=TRUE;
		}
	}
	return (buf);
}


short enc_anim(ibuf,file)
struct ImBuf *ibuf;
int file;
{
	int step, steps, size, i, skip;
	uchar *buf1, *crect, *_buf1, *_buf2, *bufend, *buf2;
	short ok = TRUE;

	if (ibuf == 0) return (0);
	if (file < 0 ) return (0);
	if (ibuf->rect == 0) return(0);

	/* dither toevoegen */

	switch(ibuf->ftype){
	case AN_c233:
		if ((ibuf->flags & IB_cmap) == 0) {
		    flipy(ibuf);
		    dit2(ibuf,1,2);
		    dit2(ibuf,2,3);
		    dit2(ibuf,3,3);
		}
		steps = 2;
		break;
	case AN_yuvx:
		if ((ibuf->flags & IB_cmap) == 0) {
			cspace(ibuf, rgbyuv);
		    flipy(ibuf);
			yrb_add_dit2(ibuf, 1);
			yrb_add_dit4(ibuf, 2);
			yrb_add_dit2(ibuf, 3);
		}
		steps = 2;
		converttoyuvx(ibuf);
		break;
	case AN_tanx:
		if ((ibuf->flags & IB_cmap) == 0) {
			gamwarp(ibuf, 1.0 / adat_gamma);
			cspace(ibuf, rgbyuv);
			atan_space(ibuf);
		    flipy(ibuf);
			tan_add_dit4(ibuf, 1);
			tan_add_dit2(ibuf, 2);
			tan_add_dit4(ibuf, 3);
		}
		steps = 2;
		converttotanx(ibuf);
		break;
	case AN_hamx:
		ibuf->cmap = (uint *) cmap_hamx;
		ibuf->mincol = 0;
		ibuf->maxcol = sizeof(cmap_hamx) / 4;
		converttoham(ibuf);
		steps = 2;
		break;
	}

	size = ((ibuf->x + 1)* (ibuf->y + 1)) / steps + 1024;
	if ((_buf1  = malloc(size)) == 0) return(0);
	if ((_buf2  = malloc(size)) == 0){
		free(_buf1);
		return(0);
	}

	skip = 4 * steps;
	for (step = 0 ; step < steps ; step ++){
		crect = (uchar *) ibuf->rect;
		crect += 4 * step;
		size = (ibuf->x * ibuf->y + steps - step - 1) / steps;
		buf1 = _buf1;
		if ((ibuf->ftype == AN_hamx) || (ibuf->ftype == AN_yuvx)){
			crect += 3;
			for (i = size ; i>0 ; i--){
				*(buf1 ++) = *crect;
				crect += skip;
			}
		} else if (ibuf->ftype == AN_tanx) {
			for (i = size ; i > 0 ; i--){
				*(buf1 ++) = *crect;
				crect += skip;
			}
		} else{
			for (i = size ; i>0 ; i--){
				*(buf1 ++) = crect[1] + (crect[2] >> 2) + (crect[3] >> 5);
				crect += skip;
			}
		}
		bufend = makebody_anim(size,_buf2,_buf1);
		if (bufend == 0){
			ok = FALSE;
			break;
		}
		size = bufend - _buf2;
		if (write(file, _buf2, size) != size){
			ok = FALSE;
			break;
		}
	}
	free(_buf1);
	free(_buf2);
	return (ok);
}

